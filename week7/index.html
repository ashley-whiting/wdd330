<!doctype html>
<html>
<head>
  <title>WDD 330 Portfolio</title>
 
  <style>
      body{
          background-color:#e6f3f8;
          font-family: Arial, Helvetica, sans-serif;
      }
      h3{
          text-decoration: underline;
      }
      #highlight{
          background-color: rgb(241, 241, 166)
      }
      #remember{
          background-color: lightskyblue;
      }
      #code{
          font-family: 'Courier New', Courier, monospace;
      }
      #color{
          background-color: #FF7F7F;
      }
  </style>
  
  <script>

function exampleLink(){

const links = [
    {label: "Ajax in Action", url: "ajax.html"}
   
    

]


let list = document.getElementById("exampleList");

for(let i=0; i< links.length; i++){
    let item = document.createElement('li');
    let a = document.createElement('a');

    var anchor = document.createTextNode(links[i].label);
    a.appendChild(anchor);
    a.href = links[i].url;
    item.appendChild(a);

    list.appendChild(item);
}

}

  </script>
  

</head>

<body onload="exampleLink()"></body>
<body>
  <h1>WDD 330 Portfolio | Week7</h1>

<h2>Chapter 11 Further Functions</h2>

<h3>Immediately Invoked function Expressions (IIFE)</h3>
<p>-Functions that are invoked as soon as it’s defined. </p>
<p><b>*Why?</b><br>
	-Temporary Variables: a variable that is only required temporarily. Place code that uses the temporary variables inside an IIFE will ensure it’s only available while the IIFE is invoked. 
</p>
<p> Example:</p>
<p id="code">let a = 1;let b = 2;<br>
    (()=>{    const temp = a;    a = b;    b = temp;})();<br>
    a;<< 2<br>
    b;<< 1<br>
    console.log(temp);<< Error: "temp is not defined"
    </p>
    <p>The variable temp does not exist after the function has been invoked. </p>
    <p id="highlight">QUESTION: So does that mean that this function can only be called once? Or do the temporary variables only work only work each time the function is called?</p>

    <p style="text-decoration: underline;">Other reasons IIFE would be appropriate:</p>
    <ul>
        <li>Initialization code</li>
        <li>Safe Use of Strict Mode</li>
        <li>Creating Self-contained Code Blocks </li>
    </ul>

<h3>Functions that Define and Rewrite Themselves </h3>  
<p><em>Init-Time Branching</em><br>
     -enables the functions to work more effectively in the browser, and avoid checking for features every time they’re invoked.</p>
       
<p><b>Recursive Functions:</b> A function that invokes itself until a certain condition is met. Useful when iterative processes are involved. </p> 
<p>Example:</p>  
<p id="code">function factorial(n) {<br>
        if (n === 0) {        return 1; <br>
           } else {        return n * factorial(n - 1);    }}</p>
<p>The function will continue to invoke itself until finally the argument is 0 and 1 is returned. </p>

<h3>Callbacks</h3>
<p>Functions passed to other functions as argument and then invoked inside the function they are passed to. <br>
    <b>Event-driven Asynchronous Programming:</b> instead of waiting for an even to occur, a callback can be created that’s invoked when the event happens.<br>
        <b>**</b>Spaghetti code: when more than one callback is used in the same function, resulting in a large number of nested blocks that are difficult to comprehend. 
    </p>
 <p><b>Promise LifeCycle</b></p>   
 <p>Settled promise outcomes:</p>
 <ul>
     <li>Resolved: the asynchronous operation was completed successfully.</li>
     <li>Rejected: the asynchronous operation didn’t work as expected, wasn’t successfully completed or resulted in an error.</li>
 </ul>

 <p><b>Creating a Promise:</b></p>
 <p>A promise is created using a constructor function. This takes a function called an executor as an argument. The executor initializes the promise and starts the asynchronous operation.<br> 
    Example:
    </p>
 <p id="code">const promise = new Promise( (resolve, reject) => { <br>
       // initialization code goes here<br>
           if (success) {        resolve(value);<br>
            } else {        reject(error);    }});</p>   

<p><b>Async Functions</b></p>  
<p>Async functions are preceded by the async keyword and allow you to write asynchronous code as if it was synchronous.<br>
    This is achieved by using the await operator before an asynchronous function. This will wrap the return value of the function in a promise that can then be assigned to a variable.<br>
    Example:
    </p>          
<p id="code">async function loadGame(userName) {<br>
    try {        const user = await login(userName);<br>
          const info = await getPlayerInfo (user.id); <br>
           // load the game using the returned info    }<br>
    catch (error){        throw error;    }}
</p>
<h3>Closures</h3>
<p>A closure is a reference to a variable that was created inside the scope of another function, but is then kept alive and used in another part of the program.</p>
<p>In this EXAMPLE, an ‘inner’ function is declared inside another function and has full access to all of the variables declared inside the scope of the function<br>
     in which it’s declared (‘outer’ function). </p>
     <p id="code">function outer() { const outside = 'Outside!';<br>
         function inner() { const inside = 'Inside!'; <br>  
            console.log(outside);<br>
               console.log(inside); }<br>
                   console.log(outside);    inner();}</p>


<p><b>Returning Functions</b></p>
<p>A <em>closure</em> is formed when the inner function is returned by the outer function, maintaining access to any variables declared inside the enclosing function.</p>
<p id="code">function outer() { const outside = 'Outside!';<br>
    function inner() { const inside = 'Inside!';<br>
     console.log(outside);<br>
          console.log(inside); }<br>
              return inner;}</p>

<h3>Functional Programming </h3>
<p>Pure Functions have the following aspects:</p>
<ol>
    <li>The return value of a pure function should only depend on the values provided as arguments.<br>
         It doesn't rely on values from somewhere else in the program.</li>
    <li>There are no side-effects. A pure function doesn't change any values or data elsewhere in the program.<br>
         It only makes non-destructive data transformations and returns new values, rather than altering any of the underlying data.</li>    
    <li>Referential transparency. Given the same arguments, a pure function will always return the same result.</li>      
</ol>

<p>In order to follow these rules, any pure function must have:</p>
<ul>
    <li>At least one argument; otherwise the return value must depend on something other than the arguments of the function, breaking the first rule</li>
    <li>A return value; otherwise there’s no point in the function (unless it has changed something else in the program – in which case, it’s broken the 'no side-effects' rule).</li>
</ul>


<h2>Chapter 13 Ajax</h2>
<p><b>Asynchronous-JavaScript-XML: Ajax</b></p>
<ul>
    <li>Asynchronous: When a request for data is sent, the program doesn’t have to stop and wait for the response. </li>
    <li>JavaScript: Ajax enabled JS to send requests and receive responses from a server, allowing content to be updated in real time.</li>
    <li>XML: XML docs were used in the past to return data. Nowadays Ajax uses JSON, which is more lightweight and easier parse. </li>
</ul>

<h3>The Fetch API</h3>
<p>The Fetch API provides a global fetch() method that only has one mandatory argument, the URL of the resource you with to fetch. </p>
<p id="code">fetch('https://example.com/data')<br>
    .then( // code that handles the response )<br>
    .catch( // code that runs if the server returns an error )</p>

<p><b>The Response Interface</b></p>  
<ul>
    <li>Redirects: used to redirect to another URL</li>
    <li>Text Responses: takes a stream of text from the response, reads it and then returns a promise that resolves to a USVSting object that can be treated as a string.</li>
    <li>File Responses: blob() method reads a file of raw data such as an image or spreadsheet.</li>
    <li>JSON responses: json() mehod transforms a stream of JSON data into a promise that resolves to a JS object. </li>
</ul>  

<p><b>The Request Interface</b></p>
<p>Request objects are created using the Request() constructor, and include the following properties:</p>
<ul>
    <li>url – The URL of the requested resource (the only property that is required).</li>
    <li>method – a string that specifies which HTTP method should be used for the request. By default, this is 'GET'.</li>
    <li>headers – This is a Headers object that provides details of the request's headers.</li>
    <li>mode – Allows you to specify if CORS is used or not. CORS is enabled by default.</li>
    <li>cache – Allows you to specify how the request will use the browser's cache. <br>
        For example, you can force it to request a resource and update the cache with the result, or you can force it to only look in the cache for the resource.</li>
    <li>credentials – Lets you specify if cookies should be allowed with the request.</li>
    <li>redirect – Specifies what to do if the response returns a redirect. There’s a choice of three values:<br>
         'follow' (the redirect is followed), 'error' (an error is thrown) or 'manual' (the user has to click on a link to follow the redirect).</li>
</ul>

<p><b>Headers Interface</b></p>
<p>HTTP headers are used to pass on any additional information about a request or response.</p>
<p id="remember">Typical information contained in headers includes the:</p>
<ul>
    <li>File-type of the resource</li>
    <li>Cookie information</li>
    <li>Authentication information</li>
    <li>When the resource was last modified</li>
</ul>

<p><b>Putting it all Together:</b></p>
<p id="code">
const url = 'https:example.com/data';<br>
const headers = new Headers({ 'Content-Type': 'text/plain', 'Accept-Charset' : 'utf-8', 'Accept-Encoding':'gzip,deflate' })<br>
const request = (url,{    headers: headers})<br>
fetch(request).then( function(response) {<br>
    if(response.ok) {return response;} <br>
    throw Error(response.statusText);})<br>
.then( response => // do something with response ).catch( error => console.log('There was an error!') )

</p>

<h3>Receiving Information</h3>
<ul id="exampleList">

</ul>


</body>
</html>